#onset_diff_1p=data$roll_1p[8],
roll_2p=data_cut2$roll_2p[nrow(data_cut2)])
data_cut2 <- data_cut2 %>%
rows_insert(new_row2, by = names(new_row2))
data_til_end <- data[(skips[2]):nrow(data),]
data_full <- rbind(data_cut1, data_cut2, data_til_end)
}
#cut the data frame from the start to the first missed hit flag
data_cut1 <- data[1:skips[1] - 1,]
#create new row with info about which participant missed, imputed value
#and lag
new_row1 <- tibble(participant=new_p[1],
onset_diff_2p=data$roll_2p[skips[1] - 1],
#onset_diff_1p=data$roll_1p[60],
roll_2p=data$roll_2p[skips[1] - 1])
#insert the newly created row at the bottom of the cut data frame
new_data_cut1 <- data_cut1 %>%
rows_insert(new_row1, by = names(new_row1))
# Insert as many rows as needed (as many missed hits there are)
i = 1
while(i < length(skips)){
#cut the data at the right spot, and name according to missed hit index
assign(paste0("data_cut", (i+1)),
data[skips[i]:(skips[i+1]-1),])
i = i + 1
}
#Create the new rows to append to the cuts created above
i = 1
while(i < length(skips)){
attach(get(paste0("data_cut", (i+1))))
assign(paste0("new_row", (i+1)),
tibble(participant=new_p[i + 1],
onset_diff_2p= get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))],
#onset_diff_1p=data$roll_1p[8],
roll_2p=get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))]))
detach(get(paste0("data_cut", (i+1))))
i = i + 1
}
#Create the new rows to append to the cuts created above
i = 1
while(i < length(skips)){
attach(get(paste0("data_cut", (i+1))))
assign(paste0("new_row", (i+1)),
tibble(participant=new_p[i + 1],
onset_diff_2p= get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))],
#onset_diff_1p=data$roll_1p[8],
roll_2p=get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))]))
detach(get(paste0("data_cut", (i+1))))
i = i + 1
}
#Insert the new rows to their corresponding data frame
for(i in 1:length(skips)){
if((i + 1) <= length(skips) ){
assign(paste0("new_data_cut", (i+1)),
rows_insert(get(paste0("data_cut", i+1)),
get(paste0("new_row", (i+1))),
by = names(get(paste0("new_row", (i +1))))))
}
}
?do.call
#bind all cuts together, accommodating different size
start_block <- do.call(rbind,lapply(ls(patt="new_data_cut", envir = .GlobalEnv), get), envir = .GlobalEnv)
data_til_end <- data[tail(skips, n = 1):nrow(data),]
data_full <- rbind(start_block, data_til_end)
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(zoo)
library(ggplot2)
###TASK###
# 3Put expected pulse for synch condition from kick and snare and deviation
# 2accuracy metric
# 1group by even and odd trial such that participant ID consistent across trials
# 4 use midi as the model of how we want to visualize
#TODO if else to get participant number correct
# Plotting boundaries of end of synch phase and when they drum independent
# Importing
#101_trial 1 bad
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Data Cleaning and Restructuring
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
InsertMissedHits <- function(data){
skips <- which(data$flag_skip==1)
p_skip <- (data[skips[1:length(skips)],1])
new_p <- ifelse(p_skip$participant == 2, 1,
ifelse(p_skip$participant == 1, 2, NA))
if(length(skips) == 0){
data_full <- data
}
else if(length(skips) == 1){
data_cut1 <- data[1:(skips[1] - 1),]
new_row1 <- tibble(participant=new_p[1],
onset_diff_2p=data$roll_2p[skips[1] - 1],
#onset_diff_1p=data$roll_1p[60],
roll_2p=data$roll_2p[skips[1] - 1])
data_cut1 <- data_cut1 %>%
rows_insert(new_row1, by = names(new_row1))
data_til_end <- data[skips[1]:nrow(data),]
data_full <- rbind(data_cut1, data_til_end)
}
else if(length(skips) == 2){
data_cut1 <- data[1:skips[1] - 1,]
new_row1 <- tibble(participant=new_p[1],
onset_diff_2p=data$roll_2p[skips[1] - 1],
#onset_diff_1p=data$roll_1p[60],
roll_2p=data$roll_2p[skips[1] - 1])
data_cut1 <- data_cut1 %>%
rows_insert(new_row1, by = names(new_row1))
data_cut2 <- data[skips[1]:(skips[2]-1),]
new_row2 <- tibble(participant=new_p[2],
onset_diff_2p=data_cut2$roll_2p[nrow(data_cut2)],
#onset_diff_1p=data$roll_1p[8],
roll_2p=data_cut2$roll_2p[nrow(data_cut2)])
data_cut2 <- data_cut2 %>%
rows_insert(new_row2, by = names(new_row2))
data_til_end <- data[(skips[2]):nrow(data),]
data_full <- rbind(data_cut1, data_cut2, data_til_end)
}
else if(length(skips) >= 3){
#cut the data frame from the start to the first missed hit flag
data_cut1 <- data[1:skips[1] - 1,]
#create new row with info about which participant missed, imputed value
#and lag
new_row1 <- tibble(participant=new_p[1],
onset_diff_2p=data$roll_2p[skips[1] - 1],
#onset_diff_1p=data$roll_1p[60],
roll_2p=data$roll_2p[skips[1] - 1])
#insert the newly created row at the bottom of the cut data frame
new_data_cut1 <- data_cut1 %>%
rows_insert(new_row1, by = names(new_row1))
# Insert as many rows as needed (as many missed hits there are)
i = 1
while(i < length(skips)){
#cut the data at the right spot, and name according to missed hit index
assign(paste0("data_cut", (i+1)),
data[skips[i]:(skips[i+1]-1),])
i = i + 1
}
#Create the new rows to append to the cuts created above
i = 1
while(i < length(skips)){
attach(get(paste0("data_cut", (i+1))))
assign(paste0("new_row", (i+1)),
tibble(participant=new_p[i + 1],
onset_diff_2p= get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))],
#onset_diff_1p=data$roll_1p[8],
roll_2p=get("roll_2p")[nrow(get(paste0("data_cut", (i+1))))]))
detach(get(paste0("data_cut", (i+1))))
i = i + 1
}
#Insert the new rows to their corresponding data frame
for(i in 1:length(skips)){
if((i + 1) <= length(skips) ){
assign(paste0("new_data_cut", (i+1)),
rows_insert(get(paste0("data_cut", i+1)),
get(paste0("new_row", (i+1))),
by = names(get(paste0("new_row", (i +1))))))
}
}
#bind all cuts together, accommodating different size
start_block <- do.call(rbind,lapply(ls(patt="new_data_cut", envir = .GlobalEnv), get), envir = .GlobalEnv)
print(environment())
data_til_end <- data[tail(skips, n = 1):nrow(data),]
data_full <- rbind(start_block, data_til_end)
}
}
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(zoo)
library(ggplot2)
###TASK###
# 3Put expected pulse for synch condition from kick and snare and deviation
# 2accuracy metric
# 1group by even and odd trial such that participant ID consistent across trials
# 4 use midi as the model of how we want to visualize
#TODO if else to get participant number correct
# Plotting boundaries of end of synch phase and when they drum independent
# Importing
#101_trial 1 bad
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Data Cleaning and Restructuring
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
#bind all cuts together, accommodating different size
start_block <- do.call(rbind,lapply(ls(patt="new_data_cut", envir = environment()), get))
print(environment())
data_til_end <- data[tail(skips, n = 1):nrow(data),]
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(zoo)
library(ggplot2)
###TASK###
# 3Put expected pulse for synch condition from kick and snare and deviation
# 2accuracy metric
# 1group by even and odd trial such that participant ID consistent across trials
# 4 use midi as the model of how we want to visualize
#TODO if else to get participant number correct
# Plotting boundaries of end of synch phase and when they drum independent
# Importing
#101_trial 1 bad
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Data Cleaning and Restructuring
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
library(rlang)
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(rlang)
library(zoo)
library(ggplot2)
###TASK###
# 3Put expected pulse for synch condition from kick and snare and deviation
# 2accuracy metric
# 1group by even and odd trial such that participant ID consistent across trials
# 4 use midi as the model of how we want to visualize
#TODO if else to get participant number correct
# Plotting boundaries of end of synch phase and when they drum independent
# Importing
#101_trial 1 bad
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Data Cleaning and Restructuring
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
#bind all cuts together, accommodating different size
env_print(global)
start_block <- do.call(rbind,lapply(ls(patt="new_data_cut"), get, envir = environment()))
environment()
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(rlang)
library(zoo)
library(ggplot2)
###TASK###
# 3Put expected pulse for synch condition from kick and snare and deviation
# 2accuracy metric
# 1group by even and odd trial such that participant ID consistent across trials
# 4 use midi as the model of how we want to visualize
#TODO if else to get participant number correct
# Plotting boundaries of end of synch phase and when they drum independent
# Importing
#101_trial 1 bad
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Data Cleaning and Restructuring
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
### Social Drumming Analysis ###
rm(list=ls())
user <- "SM"
if(user == "SM"){
data_dir <- "C:\\Users\\mcwee\\OneDrive - McMaster University\\Social Drumming\\REAPER_trial_data\\"
setwd("C:\\Users\\mcwee\\Documents\\LIVELab\\Social_Drumming\\social_drumming_git\\")
} else if(user == "AL"){
setwd("~/McMaster/Third Year/PNB 3QQ3/Drumming and Cooperation/Data")
data_dir <- ""
} else if(user == "YAS"){
data_dir <- ""
}
source("InsertMissedHits.R")
source("RemoveDoubleHits.R")
library(tidyverse)
library(rlang)
library(zoo)
library(ggplot2)
data <- read.csv(paste0(data_dir, "116_trial1.csv"),stringsAsFactors = T)
names(data) <- c("sel", "mut", "s_ppq",  "e_ppq", "leng", "chan", "pitch", "vel")
# Renaming variables to be readable
data <- data %>%
mutate(s_ppq = (s_ppq/(960*2)),e_ppq = (e_ppq/(960*2))) %>%
rename(start_s = s_ppq,end_s = e_ppq) %>%
select(-sel, -mut, -chan, -vel)
#adding a participant number to each drummer
data$participant <- ifelse(data$pitch==47,1,2)
#onset difference between 2 participants and individual participants
data$onset_diff_2p <- data$start_s - lag(data$start_s, 1)
data <- data %>%
group_by(participant) %>%
mutate(onset_diff_1p = start_s - lag(start_s, 1))
#Skip flagging mechanisms
data$flag_skip <- ifelse(data$participant + lag(data$participant,1) == 3,0,1)
# Rolling averages
data <- data %>%
group_by(participant) %>%
mutate(roll_1p = rollmean(onset_diff_1p, k=5, align = "right", fill = NA))
data <- data %>%
ungroup %>%
mutate(roll_2p = rollmean(onset_diff_2p, k=5, align = "right", fill = NA))
# Cleaning pt 2
data <- data %>%
select(-start_s, -end_s, -leng, -pitch)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- RemoveDoubleHits(data)
which(data$flag_skip == 1)
sum(data$flag_skip, na.rm = T)
data <- data[c(-6, -24,-25),]
data_full <- InsertMissedHits(data)
data_full
